{"name":"Binary-parser","tagline":"Blazing-fast binary parser builder for node.js","body":"# Binary-parser\r\n\r\n[![Build Status](https://api.shippable.com/projects/540e7af73479c5ea8f9ebc33/badge?branchName=master)](https://app.shippable.com/projects/540e7af73479c5ea8f9ebc33/builds/latest)\r\n\r\nBinary-parser is a binary parser builder library for [node](http://nodejs.org),\r\nwhich enables you to write efficient parsers in a simple & declarative way.\r\n\r\nIt supports all common data types required to analyze a structured binary data.\r\nBinary-parser dynamically generates and compiles the parser code on-the-fly,\r\nwhich runs as fast as a hand-written parser (which takes much more time and effort to write).\r\nSupported data types are:\r\n\r\n- Integers (supports 8, 16, 32 bit signed- and unsigned integers)\r\n- Floating point numbers (supports 32 and 64 bit floating point values)\r\n- Bit fields (supports bit fields with length from 1 to 32 bits)\r\n- Strings (supports various encodings, fixed-length and variable-length, zero terminated string)\r\n- Arrays (supports user-defined element type, fixed-length and variable-length)\r\n- Choices\r\n- User defined types\r\n\r\nThis library's features are inspired by [BinData](https://github.com/dmendel/bindata)\r\n, its syntax by [binary](https://github.com/substack/node-binary).\r\n\r\n## Installation\r\nBinary-parser can be installed with [npm](https://npmjs.org/):\r\n\r\n```shell\r\n$ npm install binary-parser\r\n```\r\n\r\n## Quick Start\r\n1. Create an empty Parser object with `new Parser()`.\r\n2. Chain builder methods to build the desired parser. (See [API](https://github.com/Keichi/binary-parser#api) for detailed document\r\nof each methods)\r\n3. Call `Parser.prototype.parse` with an `Buffer` object passed as argument.\r\n4. Parsed result will be returned as an object.\r\n\r\n```javascript\r\n// Module import\r\nvar Parser = require('binary-parser').Parser;\r\n\r\n// Build an IP packet header Parser\r\nvar ipHeader = new Parser()\r\n    .endianess('big')\r\n    .bit4('version')\r\n    .bit4('headerLength')\r\n    .uint8('tos')\r\n    .uint16('packetLength')\r\n    .uint16('id')\r\n    .bit3('offset')\r\n    .bit13('fragOffset')\r\n    .uint8('ttl')\r\n    .uint8('protocol')\r\n    .uint16('checksum')\r\n    .array('src', {\r\n        type: 'uint8',\r\n        length: 4\r\n    })\r\n    .array('dst', {\r\n        type: 'uint8',\r\n        length: 4\r\n    });\r\n\r\n// Prepare buffer to parse.\r\nvar buf = new Buffer('450002c5939900002c06ef98adc24f6c850186d1', 'hex');\r\n\r\n// Parse buffer and show result\r\nconsole.log(ipHeader.parse(buf)); \r\n```\r\n\r\n## API\r\n\r\n### new Parser()\r\nConstructs a Parser object. Returned object represents a parser which parses nothing.\r\n\r\n### parse(buffer[, callback])\r\nParse a `Buffer` object `buffer` with this parser and return the resulting object.\r\nWhen `parse(buffer)` is called for the first time, parser code is compiled on-the-fly\r\nand internally cached.\r\n\r\nIf parser's `async` option is `true`, then a callback function has to be passed as an\r\nargument. This callback should take two arguments like other node.js callbacks:\r\n`function(err, result)`.\r\n\r\n### create(constructorFunction)\r\nSet the constructor function that should be called to create the object returned from\r\nthe `parse` method.\r\n\r\n### [u]int{8, 16, 32}{le, be}(name [,options])\r\nParse bytes as an integer and store it in a variable named `name`. `name` should consist\r\nonly of alphanumeric characters and start with an alphabet.\r\nNumber of bits can be chosen from 8, 16 and 32.\r\nByte-ordering can be either `l` for little endian or `b` for big endian.\r\nWith no prefix, it parses as a signed number, with `u` prefixed as an unsigned number. \r\n\r\n```javascript\r\nvar parser = new Parser()\r\n\t// Signed 32-bit integer (little endian)\r\n    .int32le('a')\r\n    // Unsigned 8-bit integer\r\n    .uint8('b')\r\n    // Signed 16-bit integer (big endian)\r\n    .int16be('c')\r\n```\r\n\r\n### bit\\[1-32\\](name [,options])\r\nParse bytes as a bit field and store it in variable `name`. There are 32 methods from\r\n`bit1` to `bit32` each corresponding to 1-bit-length to 32-bits-length bit field.\r\n\r\n### {float, double}{le, be}(name [,options])\r\nParse bytes as an floating-point value and store it in a variable\r\nnamed `name`. `name` should consist only of alphanumeric characters and start \r\nwith an alphabet.\r\n\r\n```javascript\r\nvar parser = new Parser()\r\n    // 32-bit floating value (big endian)\r\n    .floatbe('a')\r\n    // 64-bit floating value (little endian)\r\n    .doublele('b')\r\n```\r\n\r\n### string(name [,options])\r\nParse bytes as a string. `name` should consist only of alpha numeric characters and start\r\nwith an alphabet. `options` is an object; following options are available: \r\n\r\n- `encoding` - (Optional, defaults to `utf8`) Specify which encoding to use. `'utf8'`, `'ascii'`, `'hex'` and else\r\n\tare valid. See [`Buffer.toString`](http://nodejs.org/api/buffer.html#buffer_buf_tostring_encoding_start_end) for more info.\r\n- `length ` - (Required) Length of the string. Can be a number, string or a function.\r\n\tUse number for statically sized arrays, string to reference another variable and\r\n\tfunction to do some calculation.\r\n- `zeroTerminated` - (Optional, defaults to `false`) If true, then this parser reads until it reaches zero.\r\n\r\n### buffer(name [,options])\r\nParse bytes as a buffer. `name` should consist only of alpha numeric characters and start\r\nwith an alphabet. `options` is an object; following options are available: \r\n\r\n- `clone` - (Optional, defaults to `false`) By default, `buffer(name [,options])` returns a new buffer which references\r\n    the same memory as the parser input, but offset and cropped by a certain range. If this option is true, input buffer\r\n    will be cloned and a new buffer referncing another memory is returned.\r\n- `length ` - (either `length` or `readUntil` is required) Length of the buffer. Can be a number, string or a function.\r\n    Use number for statically sized buffers, string to reference another variable and\r\n    function to do some calculation.\r\n- `readUntil` - (either `length` or `readUntil` is required) If `'eof'`, then this parser\r\n    will read till it reaches end of the `Buffer` object.\r\n\r\n\r\n### array(name [,options])\r\nParse bytes as an array. `options` is an object; following options are available: \r\n\r\n- `type` - (Required) Type of the array element. Can be a string or an user defined Parser object.\r\n    If it's a string, you have to choose from [u]int{8, 16, 32}{le, be}.\r\n- `length` - (either `length` or `readUntil` is required) Length of the array. Can be a number, string or a function.\r\n\tUse number for statically sized arrays.\r\n- `readUntil` - (either `length` or `readUntil` is required) If `'eof'`, then this parser\r\n\twill read till it reaches end of the `Buffer` object.\r\n\r\n```javascript\r\nvar parser = new Parser()\r\n\t// Statically sized array\r\n\t.array('data', {\r\n\t\ttype: 'int32',\r\n\t\tlength: 8\r\n\t})\r\n\t\r\n\t// Dynamically sized array (reference another variable)\r\n\t.uint8('dataLength')\r\n\t.array('data2', {\r\n\t\ttype: 'int32',\r\n\t\tlength: 'dataLength'\r\n\t})\r\n\t\r\n\t// Dynamically sized array (with some calculation)\r\n\t.array('data3', {\r\n\t\ttype: 'int32',\r\n\t\tlength: function() { return this.dataLength - 1; } // other fields are available through this\r\n\t});\r\n\t\r\n\t// Use user defined parser object\r\n\t.array('data4', {\r\n\t\ttype: userDefinedParser,\r\n\t\tlength: 'dataLength'\r\n\t})\r\n```\r\n\r\n### choice(name [,options])\r\nChoose one parser from several choices according to a field value.\r\nCombining `choice` with `array` is useful for parsing a typical\r\n[Type-Length-Value](http://en.wikipedia.org/wiki/Type-length-value) styled format.\r\n\r\n- `tag` - (Required) The value used to determine which parser to use from the `choices`\r\n\tCan be a string pointing to another field or a function. \r\n- `choices` - (Required) An object which key is an integer and value is the parser which is executed\r\n\twhen `tag` equals the key value.\r\n- `defaultChoice` - (Optional) In case of the tag value doesn't match any of `choices` use this parser.\r\n\r\n```javascript\r\nvar parser1 = ...;\r\nvar parser2 = ...;\r\nvar parser3 = ...;\r\n\r\nvar parser = new Parser()\r\n\t.uint8('tagValue')\r\n\t.choice('data', {\r\n\t\ttag: 'tagValue',\r\n\t\tchoices: [\r\n\t\t\t1: parser1, // When tagValue == 1, execute parser1\r\n\t\t\t4: parser2, // When tagValue == 4, execute parser2\r\n\t\t\t5: parser3  // When tagValue == 5, execute parser3\r\n\t\t]\r\n\t});\r\n```\r\n\r\n### nest(name [,options])\r\nNest a parser in this position. Parse result of the nested parser is stored in the variable\r\n`name`.\r\n\r\n- `type` - (Required) A `Parser` object.\r\n\r\n### skip(length)\r\nSkip parsing for `length` bytes.\r\n\r\n### endianess(endianess)\r\nDefine what endianess to use in this parser. `endianess` can be either `'little'` or `'big'`.\r\nThe default endianess of `Parser` is set to big-endian.\r\n\r\n```javascript\r\nvar parser = new Parser()\r\n    .endianess('le')\r\n\t// You can specify endianess explicitly\r\n\t.uint16be('a')\r\n    .uint32le('a')\r\n\t// Or you can omit endianess (in this case, little-endian is used)\r\n\t.uint16('b')\r\n\t.int32('c')\r\n```\r\n\r\n### compile()\r\nCompile this parser on-the-fly and cache its result. Usually, there is no need to\r\ncall this method directly, since it's called when `parse(buffer)` is executed\r\nfor the first time.\r\n\r\n### getCode()\r\nDynamically generates the code for this parser and returns it as a string.\r\nUsually used for debugging.\r\n\r\n### Common options\r\nThese are common options that can be specified in all parsers.\r\n\r\n- `assert` - Do assertion on the parsed result (useful for checking magic numbers and so on).\r\nIf `assert` is a `string` or `number`, the actual parsed result will be compared with it\r\nwith `===` (strict equality check), and an exception is thrown if they mismatch.\r\nOn the other hand, if `assert` is a function, that function is executed with one argument\r\n(parsed result) and if it returns false, an exception is thrown.\r\n\r\n    ```javascript\r\n    // simple maginc number validation\r\n    var ClassFile =\r\n    \tParser.start()\r\n        .endianess('big')\r\n        .uint32('magic', {assert: 0xcafebabe})\r\n\r\n    // Doing more complex assertion with a predicate function\r\n    var parser = new Parser()\r\n        .int16le('a')\r\n        .int16le('b')\r\n        .int16le('c', {\r\n            assert: function(x) {\r\n                return this.a + this.b === x;\r\n            }\r\n        });\r\n    ```\r\n\r\n- `async` - If `true`, then this parser will be executed asynchronously. You also have\r\nto pass a callback function to `Parser.parse(buffer, callback)`.\r\n\r\n## Examples\r\nSee `example` for more complex examples.\r\n\r\n## Support\r\nPlease report issues to the [issue tracker](https://github.com/Keichi/binary-parser/issues) if you\r\nhave any difficulties using this module, found a bug, or request a new feature.\r\n\r\nPull requests with fixes and improvements are welcomed!\r\n\r\n## License\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2013 Keichi Takahashi <keichi.t@me.com>\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}